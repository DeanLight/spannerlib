# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/030_session.ipynb.

# %% auto 0
__all__ = ['logger', 'Session']

# %% ../nbs/030_session.ipynb 3
import csv

import os
import re
from pathlib import Path
from typing import Tuple, List, Union, Optional, Callable, Type, Iterable, no_type_check, Sequence
from fastcore.basics import patch
from IPython import display
from singleton_decorator import singleton
from numbers import Real
import pandas as pd
import os
from itables import init_notebook_mode,show
import logging
logger = logging.getLogger(__name__)

from graph_rewrite import draw

from .utils import checkLogs,get_base_file_path,assert_df_equals,DefaultIEs,DefaultAGGs
from .grammar import parse_spannerlog,reconstruct
from .span import Span
from spannerlib.data_types import (
    _infer_relation_schema,
     Var,
    FreeVar,
    RelationDefinition,
    Relation,
    IEFunction,
    AGGFunction,
    IERelation,
    Rule,
    pretty,
)
from .engine import Engine

from spannerlib.micro_passes import (
    convert_primitive_values_to_objects,
    CheckReservedRelationNames,
    dereference_vars,
    check_referenced_paths_exist,
    inline_aggregation,
    relations_to_dataclasses,
    verify_referenced_relations_and_functions,
    rules_to_dataclasses,
    check_rule_safety,
    consistent_free_var_types_in_rule,
    assignments_to_name_val_tuple,
)


# %% ../nbs/030_session.ipynb 4
def _load_stdlib():
    # make sure we import the modules that register the stdlib
    import spannerlib.ie_func.basic 
    import spannerlib.ie_func.json_path


# %% ../nbs/030_session.ipynb 5
def _class_repr(x):
    """returns the repr of x if x is a Span, else returns x
    used to display spans in a more readable way in pandas 
    """
    if not isinstance(x,(str,float,int,bool)):
        return f"{repr(x)}"
    return x

# %% ../nbs/030_session.ipynb 6
class Session():
    def __init__(self,
    register_stdlib=True, # if True, registers the standard library of IEs and AGGs
    ):
        """
        A Session object is the main interface to the spannerlog engine. 
        It is used to parse, check semantics, plan and execute queries.
        It allows importing data and callbacks to the Spannerlog engine and exporting data from the engine back to python.
        """

        self.pass_stack = [
            convert_primitive_values_to_objects,
            CheckReservedRelationNames('spanner_'),
            check_referenced_paths_exist,
            dereference_vars,
            inline_aggregation,
            relations_to_dataclasses,
            verify_referenced_relations_and_functions,
            rules_to_dataclasses,
            check_rule_safety,
            consistent_free_var_types_in_rule,
            assignments_to_name_val_tuple,
        ]

        self.clear(register_stdlib=register_stdlib)

# %% ../nbs/030_session.ipynb 7
@patch
def clear(self:Session,
    register_stdlib=True, # if True, registers the standard library of IEs and AGGs
    ):
    """Resets the engine and clears all relations, functions and rules."""
    self.engine = Engine()
    if not register_stdlib:
        return
    _load_stdlib()
    for ie_def in DefaultIEs().as_list():
        self.register(*ie_def)
    for agg_def in DefaultAGGs().as_list():
        self.register_agg(*agg_def)


# %% ../nbs/030_session.ipynb 9
@patch
def register(self:Session,
    name, # name of the IE function in spannerlog
    func, # the python function that implements the IE
    in_schema, # the schema of the input relation
    out_schema, # the schema of the output relation
    ):
    """Registers an IE function with the spannerlog engine."""
    ie_func_obj = IEFunction(name=name,func=func,in_schema=in_schema,out_schema=out_schema)
    self.engine.set_ie_function(ie_func_obj)


# %% ../nbs/030_session.ipynb 10
@patch
def register_agg(self:Session,
        name, # name of the AGG function in spannerlog
        func, # the python function that implements the AGG
        in_schema, # the schema of the input relation, can be of arity 1 only
        out_schema # the schema of the output relation, can be of arity 1 only
    ):
    """Registers an AGG function with the spannerlog engine."""
    agg_func_obj = AGGFunction(name=name,func=func,in_schema=in_schema,out_schema=out_schema)
    self.engine.set_agg_function(agg_func_obj)


# %% ../nbs/030_session.ipynb 11
@patch
def import_rel(self:Session,
    name:str, # name of the relation in spannerlog
    data:Union[str,Path,pd.DataFrame], # either a pandas dataframe or a path to a csv file
    delim:str = None, # the delimiter of the csv file
    header = None, # the header of the csv file
    ):
    """Imports a relation into the current session, either from a dataframe or from a csv file."""
    if isinstance(data, (Path,str)):
        csv_file_name = Path(data)
        if not csv_file_name.is_file():
            raise IOError("csv file does not exist")
        if os.stat(csv_file_name).st_size == 0:
            raise IOError("csv file is empty")
        data = pd.read_csv(csv_file_name, delimiter=delim,header=header)

    first_row = list(data.iloc[0,:])
    scheme = _infer_relation_schema(first_row)
    rel_def = RelationDefinition(name=name,scheme=scheme)
    self.engine.set_relation(rel_def)
    self.engine.add_facts(name,data)


# %% ../nbs/030_session.ipynb 12
@patch
def import_var(self:Session,
    name, # name of the variable in spannerlog
    value, # the value of the variable
    ):
    """Imports a variable into the current session."""
    self.engine.set_var(name,value)

# %% ../nbs/030_session.ipynb 14
# parsing statements
#TODO from here seperate parse and check semantics so we can know the number of statements
# before we iterate on semantic checks that might depend on execution of previous statements
@patch
def _parse_code(self:Session,code):
    """Parses a spannerlog code snippet and returns a list of statements."""
    try:
        statements = parse_spannerlog(code,split_statements=True)
    except Exception as e:
        print(f"Syntax ERROR:\n{e}\n")
        raise e
    return statements

@patch
def _check_semantics(self:Session,statements):
    """An iterator for performing semantic checks on a list of statements.
    Yields the AST and the Lark parse tree of each statement.

    Each statement must be executed, between yields in order to check the semantics
    of the next statement based on the side effects of the previous statement.
    """
    for statement_nx,statement_lark in statements:
        ast = statement_nx
        for pass_ in self.pass_stack:
            try:
                pass_(ast,self.engine)
            except Exception as e:
                print(
                    f"SEMANTIC ERROR:\n"
                    f"During semantic checks for statement \n\"{reconstruct(statement_lark)}\"\n"
                    f"in pass {pass_} the following exception was raised:\n{e}\n"
                    )
                raise e
        yield ast,statement_lark

# %% ../nbs/030_session.ipynb 15
## executing statements
def _statement_type_and_value(ast):
    """gets the type and value of a statement from the ast
    assumes an ast with a single node
    """
    statement_node = list(ast.nodes)[0]
    node_data = ast.nodes[statement_node]
    statement = node_data['type']
    value = node_data['val']
    return statement,value


def _execute_statement(
    ast, # networkx ast after semantic checks, should have a single node with a single statement
    engine, # the spannerlog engine to execute the statement on
    plan_only=False, # if True, plans queries returns the graph and root, but does not execute them
    draw_graph=False, # if True, draws the graph of the query plan
    ):
    """executes a single statement from the ast
    """
    statement,value = _statement_type_and_value(ast)
    match statement:
        case 'assignment':
            engine.set_var(*value)
        case 'read_assignment':
            engine.set_var(*value,read_from_file=True)
        case 'add_fact':
            engine.add_fact(value)
        case 'remove_fact':
            engine.del_fact(value)
        case 'relation_declaration':
            engine.set_relation(value)
        case 'rule':
            engine.add_rule(value)
        case 'query':
            graph,root = engine.plan_query(value)
            if draw_graph:
                draw(graph)
            if plan_only:
                return graph,root
            return engine.execute_plan(graph,root)
        case _:
            raise ValueError(f"Unknown statement type {statement}")
    return None


    

# %% ../nbs/030_session.ipynb 16
# formatting query results
def _sort_df(df):
    """sort df, if possible by value of rows else sort by string representation of rows.        
    """
    try:
        sorted_df = df.sort_values(by=list(df.columns))
    except TypeError as e:
        sorted_df = df.sort_values(by=list(df.columns),key=lambda x: tuple(str(i) for i in x) ) 
    return sorted_df

def _format_results(res):
    """format the results of a query. if a boolean dataframe is returned, return the boolean value,
    else sort the dataframe and reset the index.
    """
    if not isinstance(res,pd.DataFrame):
        return res
    if res.shape == (1,0):
        return True
    elif res.shape == (0,0):
        return False
    else:
        return _sort_df(res).reset_index(drop=True)

def _display_result(result,statement_lark):
    """format the results and display it and the query that generated it to stdout
    if its a dataframe, display it using itables"""
    if result is None:
        pass
    elif isinstance(result,pd.DataFrame):
        display.display(reconstruct(statement_lark))
        show(_format_results(result).map(_class_repr)
            .style.set_properties(**{
                'overflow-wrap': 'break-word',
                'max-width': '800px',
                'text-align': 'left'}),
            columnDefs=[{
                "targets": list(result.columns),
                "render": """function(data, type, row) {
                    return '<div style="white-space: normal; word-wrap: break-word;">' + data + '</div>';
                }""",
                "width": "300px"
            }],
            eval_functions=True,
            escape=True)
    elif isinstance(result,bool):
        display.display(reconstruct(statement_lark))
        display.display(result)
    else:
        pass



# %% ../nbs/030_session.ipynb 17
@patch
def export(self:Session,
    code:str , # the spannerlog code to execute
    display_results=False, # if True, displays the results of the query to screen
    draw_query=False, # if True, draws the query graph of queries to screen
    plan_query=False, # if True, if last statement is a query, plans the query and returns the query graph and root node.
    return_statements_meta=False, # if True, returns both the return value and the statements meta data, used internally.
    ):
    """Takes a string of spannerlog code, and executes it, returning the value of the last statement in the code string.
    All statements that are not queries, return None.
    """
    results = []
    statements = []
    parsed_statements = self._parse_code(code)
    num_statements = len(parsed_statements)
    
    for statement_index,(clean_ast,statement_lark) in enumerate(self._check_semantics(parsed_statements)):
        is_last_statement = statement_index == num_statements - 1
        plan_only = plan_query and is_last_statement
        try:
            result = _execute_statement(clean_ast,self.engine,draw_graph=draw_query,plan_only=plan_only)
            result = _format_results(result)
        except Exception as e:
            print(f"RUNTIME ERROR:\n"
                f"During execution of statement \n\"{reconstruct(statement_lark)}\"\n"
                f"the following exception was raised:\n"
                )
            raise e
        
        s_type,s_dataclass = _statement_type_and_value(clean_ast)
        statements.append((s_type,s_dataclass,reconstruct(statement_lark)))
        results.append(result)
        if display_results:
            _display_result(result,statement_lark)
    
    if len(results) == 0:
        ret_val =  None
    else:
        ret_val =  results[-1]

    if return_statements_meta:
        return ret_val,statements
    else:
        return ret_val

# %% ../nbs/030_session.ipynb 18
@patch  
def print_rules(self:Session):
    """Prints all the rules in the engine. and returns them as a list"""
    rules = list(self.engine.rules_to_ids.keys())
    for rule in rules:
        print(rule)
    return rules

@patch
def get_all_functions(self:Session):
    """Returns all the IEs and AGGs in the engine, as a nested dictionary of the form:
    {
        'ie':{name:IEFunction},
        'agg':{name:AGGFunction}
    }
    """
    return {
        'ie':self.engine.ie_functions.copy(),
        'agg':self.engine.agg_functions.copy()
    }


# %% ../nbs/030_session.ipynb 21
@patch
def remove_rule(self:Session,
    rule:str # the rule string to remove
    ):
    """removes a rule from the engine, rule string must be identical to the rule defined previously
    """
    self.engine.del_rule(rule)


# %% ../nbs/030_session.ipynb 22
@patch
def remove_head(self:Session,head:str):
    """removes all rules of a given head relation
    """
    self.engine.del_head(head)


# %% ../nbs/030_session.ipynb 23
@patch
def remove_all_rules(self:Session):
    """removes all rules from the engine
    """
    rules = list(self.engine.rules_to_ids.keys())
    for rule in rules:
        self.remove_rule(rule)


# %% ../nbs/030_session.ipynb 24
@patch
def remove_relation(self:Session,relation:str):
    """removes a relation from the engine, either a extrinsic or intrinsic relation
    """
    self.engine.del_relation(relation)



# %% ../nbs/030_session.ipynb 26
def test_session(
    code_strings,
    expected_outputs=None,# list of expected dfs
    ie_funcs=None,# List of [name,func,in_scheme,out_scheme]
    agg_funcs=None,
    csvs=None,# List of [name,df]
    debug=False,
    display_results=True,
    ):

    sess=Session()

    # add data
    if csvs:
        for name,df in csvs:
            sess.import_rel(name,df)
    # add ies
    if ie_funcs:
        for name,func,in_scheme,out_scheme in ie_funcs:
            sess.register(name,func,in_scheme,out_scheme)
    
    if agg_funcs:
        for name,func,in_scheme,out_scheme in agg_funcs:
            sess.register_agg(name,func,in_scheme,out_scheme)

    # normalize code strings and expected outputs to lists
    if not isinstance(code_strings,list):
        code_strings = [code_strings]
    if expected_outputs is None:
        expected_outputs = [None]*len(queries)
        dont_assert = True
    else:
        dont_assert = False
    if not isinstance(expected_outputs,list):
        expected_outputs = [expected_outputs]

    
    for code,expected in zip(code_strings,expected_outputs):
        try:
            res = sess.export(code,display_results=True,draw_query=debug)
        except Exception as e:
            print(f"Error in code {code}")
            raise e
        
        if dont_assert:
            continue
        if isinstance(expected,pd.DataFrame) and isinstance(res,pd.DataFrame):
            assert_df_equals(res,expected)
        else:
            assert res == expected, f"expected {expected}, got {res}"
    return sess
        

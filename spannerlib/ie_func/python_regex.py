# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/ie_func/001_basic_ies.ipynb.

# %% auto 0
__all__ = ['PYRGX', 'PYRGX_SPLIT', 'AS_STRING', 'EXPR_EVAL', 'rgx', 'rgx_split', 'as_str', 'expr_eval']

# %% ../../nbs/ie_func/001_basic_ies.ipynb 3
import re
from typing import Iterable, Sequence

from ..span import Span

# %% ../../nbs/ie_func/001_basic_ies.ipynb 5
def rgx(pattern: str, text: str) -> Iterable[Sequence]:
    """
    An IE function which runs regex using python's `re` and yields tuples of strings.

    @param text: The input text for the regex operation.
    @param regex_pattern: the pattern of the regex operation.
    @return: tuples of strings that represents the results.
    """
    text = Span(text)
    compiled_rgx = re.compile(pattern)
    num_groups = compiled_rgx.groups
    if num_groups == 0:
        for match in re.finditer(compiled_rgx, str(text)):
            i,j = match.span()
            yield (text[i:j])
    else:
        for match in re.finditer(compiled_rgx, str(text)):
            indices = (match.span(i) for i in range(1,num_groups+1))
            yield tuple([text[i:j] for i,j in indices])

PYRGX =[
    'rgx',
    rgx,
    [str, str],
    lambda arity: [str]*arity
]


# %% ../../nbs/ie_func/001_basic_ies.ipynb 13
def rgx_split(delim,text,initial_tag="Start Tag"):
    """
    An IE function which given a delimeter rgx pattern and a text, 
    returns tuples of spans of the form (delimeter_match, text_before_next_delimeter).
    Note that rgx pattern should not have any groups.

    @param delim: the delimeter pattern to use.
    @param text: the text to split
    @return: tuples of strings that represents splitting the text according to delim, 
        yields tuples of the form (delimeter_match, text_before_next_delimeter).
    """
    delim_iter = rgx(delim,text)
    try:
        first_span = next(delim_iter)
        if first_span.start != 0:
            yield(initial_tag,text[:first_span.start])
    except StopIteration:
        return
    prev_span = first_span
    for next_span in delim_iter:
        yield (prev_span, text[prev_span.end:next_span.start])
        prev_span = next_span

    yield (prev_span, text[prev_span.end:])

PYRGX_SPLIT =[
    'rgx_split',
    rgx_split,
    [str, str],
    [Span,Span],
]


# %% ../../nbs/ie_func/001_basic_ies.ipynb 16
def as_str(span):
    yield str(span),

AS_STRING = [
    'as_str',
    as_str,
    [Span],
    [str]
]


# %% ../../nbs/ie_func/001_basic_ies.ipynb 19
def expr_eval(template,*inputs):
    try:
        expr = template.format(*[f'arg_{i}' for i in range(len(inputs))])
    except (KeyError,IndexError):
        raise ValueError(f"Invalid expression template {template} for inputs {inputs}\n"
                f"make sure the expression template has only numerical indices and the number of inputs match the number of indices")
    yield eval(expr,None,{f'arg_{i}':arg for i,arg in enumerate(inputs)})

EXPR_EVAL = [
    'expr_eval',
    expr_eval,
    lambda arity: [object]*arity,
    [object]
]

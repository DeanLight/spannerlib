# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/005_spans_and_pandas.ipynb.

# %% auto 0
__all__ = ['SPAN_REPR_FORMAT', 'SPAN_TEXT_HEAD_NUM', 'small_hash', 'set_span_repr_format', 'get_span_repr_format', 'Span', 'ie']

# %% ../nbs/005_spans_and_pandas.ipynb 3
from abc import ABC, abstractmethod
import pytest

import pandas as pd
from pathlib import Path
from typing import no_type_check, Set, Sequence, Any,Optional,List,Callable,Dict,Union
from pydantic import BaseModel


# %% ../nbs/005_spans_and_pandas.ipynb 5
import hashlib

def small_hash(txt,length=6):
    """A function that returns a small hash of a string

    Args:
        txt (_type_): string to hash
        length (int, optional): length of hash. Defaults to 6.

    Returns:
        _type_: _description_
    """
    return hashlib.sha1(txt.encode()).hexdigest()[:length]

# %% ../nbs/005_spans_and_pandas.ipynb 6
SPAN_REPR_FORMAT = '''[@{doc},{start},{end}) "{text}"'''
SPAN_TEXT_HEAD_NUM = 10

def set_span_repr_format(format=None,head:int=None):
    """
    Sets the representation format for spans and the number of characters to display in the span text.

    Parameters:
        format (str, optional): The representation format for spans. Defaults to None.
        head (int, optional): The number of characters to display in the span text. Defaults to None.
    """
    global SPAN_REPR_FORMAT, SPAN_TEXT_HEAD_NUM
    if format is not None:
        SPAN_REPR_FORMAT = format
    if head is not None:
        SPAN_TEXT_HEAD_NUM = head

def get_span_repr_format() -> str:
    """
    Returns the span representation format.

    Returns:
        (the span representation format, the number of characters to display in the span text)
    """
    return SPAN_REPR_FORMAT, SPAN_TEXT_HEAD_NUM


# %% ../nbs/005_spans_and_pandas.ipynb 7
from enum import Enum
from typing import Any
from pydantic import ConfigDict

# we will have an ie function that casts a span to its string for viewing while developing - TODO

# whether we get a document as a string or as a file, we assume that it remains immutable throughout the process - TODO explain
# a user can access the original document through the span interface (currently we dont do disk caching etc so it will just be a string and not a document class) - TODO explain

class Span():
    def __init__(self,doc,start=None,end=None,name=None):
        if name is None:
            name = small_hash(doc)
        self.name=name
        self.doc = doc
        if start is None:
            start = 0
        if end is None:
            end = len(doc)
        self.start = start
        self.end = end

    def __lt__(self, other) -> bool:
        return (self.doc, self.start, self.end) <= (other.doc, other.start, other.end)
    
    def __repr__(self):
        f_string,head_num = get_span_repr_format()
        text = str(self)
        if len(text) > head_num:
            text = text[:head_num] + '...'
        return SPAN_REPR_FORMAT.format(doc=self.name,start=self.start,end=self.end,text=text)
    

    def __str__(self):
        return self.doc[self.start:self.end]

    def __eq__(self, value: object) -> bool:
        if isinstance(value, Span):
            return self.start == value.start and self.end == value.end and self.doc == value.doc
        elif isinstance(value, str):
            return str(self) == value
        else:
            return False

    def __getitem__(self, key):
        if not isinstance(key, slice):
            raise ValueError('Can only access indices of Span with slice objects')
        
        if key.step is not None:
            raise ValueError('Step not supported')
        
        start = key.start
        stop = key.stop
        if start is None:
            start = 0
        
        if stop is None:
            stop = self.end-self.start
        
        if stop > self.end-self.start:
            raise ValueError('End of slice is greater than end of span')
        if start < 0:
            raise ValueError('Negative start index not supported')
        return Span(self.doc,self.start+start, self.start+stop)
    

    @classmethod
    def from_val(cls,val):
        if isinstance(val,Span):
            return val
        if isinstance(val, (list, tuple)) and len(val) == 2:
            return Span(start=val[0], end=val[1])
        raise ValueError('Invalid value to create Vector from: {}'.format(val))
    
    # # used for sorting `Span`s in dataframes
    def __hash__(self) -> int:
        return hash((self.doc,self.start, self.end))

def ie(s:Span)->(int,int):
    return s.start,s.end

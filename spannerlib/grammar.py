# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/000_spannerlog_grammar.ipynb.

# %% auto 0
__all__ = ['logger', 'SpannerlogGrammar', 'lark_to_nx_aux', 'lark_to_nx', 'parse_spannerlog', 'reconstruct']

# %% ../nbs/000_spannerlog_grammar.ipynb 4
from typing import no_type_check, Set, Sequence, Any, Callable
from typing import Sequence, Dict
from lark import Lark,Token, Tree, Transformer
import yaml
import networkx as nx

import logging
logger = logging.getLogger(__name__)
from graph_rewrite import rewrite,rewrite_iter,draw

from .utils import checkLogs


# %% ../nbs/000_spannerlog_grammar.ipynb 6
SpannerlogGrammar = r"""
// basic text types
%import common (INT,FLOAT,CNAME,WS,WS_INLINE,NEWLINE,SH_COMMENT)
%ignore WS_INLINE
%ignore SH_COMMENT

_LINE_OVERFLOW_ESCAPE: "\\" NEWLINE
%ignore _LINE_OVERFLOW_ESCAPE

_SEPARATOR: (WS_INLINE | _LINE_OVERFLOW_ESCAPE)+
_STRING_INNER: /.+?/
_STRING_ESC_INNER: _STRING_INNER /(?<!\\)(\\\\)*?/

ESCAPED_STRING : "\"" _STRING_ESC_INNER "\""
                | "'" _STRING_ESC_INNER "'"

string: ESCAPED_STRING

_NEWLINE: NEWLINE

TRUE: "True"
FALSE: "False"

// inline version of bools in cases we dont need to save the value
_TRUE: "True"
_FALSE: "False"

bool: TRUE | FALSE
int: INT
   | "-" INT -> int_neg
float: FLOAT
   | "-" FLOAT -> float_neg

// basic terms

relation_name: CNAME
agg_name: CNAME
var_name: CNAME
free_var_name : CNAME

?const_term: string
        | float
        | int
        | bool
        | "$" var_name

?term: const_term
     | free_var_name
     

aggregated_free_var: (agg_name "(" free_var_name ")")

?decl_term: "str" -> decl_string
        | "float" -> decl_float
        | "int" -> decl_int
        | "bool" -> decl_bool


// lists of terms and relations

const_term_list: const_term ("," const_term)*
free_var_name_list: free_var_name ("," free_var_name)*
decl_term_list: decl_term ("," decl_term)*

term_list: term ("," term)*
aggregated_free_vars_list: (free_var_name|aggregated_free_var) ("," (free_var_name|aggregated_free_var))*

relation: relation_name "(" term_list ")"
ie_relation: relation_name "(" term_list ")" "->" "(" term_list ")"

// rules


?rule_body_relation: relation
                   | ie_relation

rule_head: relation_name "(" aggregated_free_vars_list ")"

rule_body_relation_list: rule_body_relation ("," rule_body_relation)*

rule: rule_head "<-" rule_body_relation_list

// statements 

relation_declaration: "new" relation_name "(" decl_term_list ")"
add_fact: relation_name "(" const_term_list ")"
        | relation_name "(" const_term_list ")" "<-" _TRUE

remove_fact: relation_name "(" const_term_list ")" "<-" _FALSE

query: "?" relation_name "(" term_list ")"

assignment: var_name "=" const_term
        | var_name "=" var_name
        | var_name "=" "read" "(" string ")" -> read_assignment
        | var_name "=" "read" "(" var_name ")" -> read_assignment

?statement: relation_declaration
          | add_fact
          | remove_fact
          | rule
          | query
          | assignment

start: (_NEWLINE)* (statement (_NEWLINE)+)* (statement)?
"""

# %% ../nbs/000_spannerlog_grammar.ipynb 9
import itertools
def lark_to_nx_aux(tree,node_id,g,counter):
    if isinstance(tree, Token):
        g.add_node(node_id,val=tree.value)
    elif isinstance(tree, Tree):
        if len(tree.children) == 0:
            node_key = "val"
        else:
            node_key = "type"
        if isinstance(tree.data,Token):
            node_val = tree.data.value
        else:
            node_val = tree.data
        g.add_node(node_id,**{node_key:node_val})
        for i,child in enumerate(tree.children):
            child_id = next(counter)
            g.add_edge(node_id,child_id,idx=i)
            lark_to_nx_aux(child,child_id,g,counter)
            


def lark_to_nx(t):
    """turn a lark tree into a networkx digraph
    data of inner nodes is saved under a key 'type'
    data of leaves is saved under a key 'val'

    Args:
        t (lark.Tree): lark tree

    Returns:
        nx.Digraph: the nx graph
    """
    g = nx.DiGraph()
    counter = itertools.count()
    lark_to_nx_aux(t,next(counter),g,counter)
    return g
    




# %% ../nbs/000_spannerlog_grammar.ipynb 10
def parse_spannerlog(spannerlog_code: str, # code to parse
    start='start', # start symbol to parse from 
    split_statements=False # whether to split the code into multiple statements, only makes sense if parsing from the start
    ):
    parser = Lark(SpannerlogGrammar, parser='lalr',start=start)
    tree = parser.parse(spannerlog_code)

    if split_statements:
        statement_trees = tree.children
        nx_graphs = [lark_to_nx(s) for s in statement_trees]
        return list(zip(nx_graphs,statement_trees))
    else: 
        return lark_to_nx(tree),tree
    

# %% ../nbs/000_spannerlog_grammar.ipynb 12
from lark.reconstruct import Reconstructor
def reconstruct(tree):
    parser = Lark(SpannerlogGrammar, parser='lalr',start='start',maybe_placeholders=False)
    return Reconstructor(parser).reconstruct(tree)
